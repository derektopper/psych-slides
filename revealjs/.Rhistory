scale_y_continuous(limits=c(0, 2)) +
geom_line(stat="density", adjust=3, col=cols[1], size=1.6) +
t
prior
L = rnorm(n=40, mean=6, sd=1)
likelihood = ggplot(data.frame(L), aes(x=L)) +
#scale_color_manual(values=cols) +
scale_color_fivethirtyeight() +
scale_x_continuous(limits=c(0, 10)) +
scale_y_continuous(limits=c(0, 3)) +
geom_line(stat="density" , adjust=1.5, color=cols[2], size=1.6) +
t
likelihood
L = rnorm(n=40, mean=6, sd=1)
likelihood = ggplot(data.frame(L), aes(x=L)) +
#scale_color_manual(values=cols) +
scale_color_fivethirtyeight() +
scale_x_continuous(limits=c(0, 10)) +
scale_y_continuous(limits=c(0, 2)) +
geom_line(stat="density" , adjust=1.5, color=cols[2], size=1.6) +
t
likelihood
L = rnorm(n=100, mean=6, sd=1)
likelihood = ggplot(data.frame(L), aes(x=L)) +
#scale_color_manual(values=cols) +
scale_color_fivethirtyeight() +
scale_x_continuous(limits=c(0, 10)) +
scale_y_continuous(limits=c(0, 2)) +
geom_line(stat="density" , adjust=1.5, color=cols[2], size=1.6) +
t
likelihood
L = rnorm(n=100, mean=6, sd=1)
likelihood = ggplot(data.frame(L), aes(x=L)) +
#scale_color_manual(values=cols) +
scale_color_fivethirtyeight() +
scale_x_continuous(limits=c(0, 10)) +
scale_y_continuous(limits=c(0, 2)) +
geom_line(stat="density" , adjust=2, color=cols[2], size=1.6) +
t
likelihood
library(rstan)
stanDso = stan_model( file="sm1.stan" )
data = list(N=length(L), y=L)
sfit = sampling(stanDso, data, iter=5000, chains=4, seed=1010)
print(sfit)
pMu = 3; pSigma = 0.3
P = rnorm(n=100, mean=pMu, sd=pSigma)
prior = ggplot(data.frame(P), aes(x=P)) +
scale_color_manual(values=cols) +
scale_x_continuous(limits=c(0, 10)) +
scale_y_continuous(limits=c(0, 2)) +
geom_line(stat="density", adjust=3, col=cols[1], size=1.6) +
t
prior
data = list(N=length(L), y=L)
sfit = sampling(stanDso, data, iter=5000, chains=4, seed=1010)
print(sfit)
L = rnorm(n=10, mean=6, sd=1)
likelihood = ggplot(data.frame(L), aes(x=L)) +
#scale_color_manual(values=cols) +
scale_color_fivethirtyeight() +
scale_x_continuous(limits=c(0, 10)) +
scale_y_continuous(limits=c(0, 2)) +
geom_line(stat="density" , adjust=2, color=cols[2], size=1.6) +
t
likelihood
data = list(N=length(L), y=L)
sfit = sampling(stanDso, data, iter=5000, chains=4, seed=1010)
print(sfit)
pD = as.data.frame(sfit, pars="mu")
posterior = ggplot(pD, aes(x=mu)) +
#scale_color_manual(values=cols) +
scale_color_fivethirtyeight() +
scale_x_continuous(limits=c(0, 10)) +
scale_y_continuous(limits=c(0, 3)) +
geom_line(stat="density", adjust=3, col=cols[3], size=1.2) +
t
posterior
hist(posterior)
hist(pD)
hist(pD[[1]])
library(grid); library(gridExtra)
g = arrangeGrob(prior, likelihood, posterior, ncol=1)
g
dataList = list(n=n, age=age, height=height)
mod = "
data{
int n;
vector[n] height;
vector[n] age;
}
parameters{
real mu;
real Bage;
real<lower=0, upper=100> sigma;
}
model{
mu ~ normal(0, 100);
Bage ~ normal(10, 10);
for (i in 1:n)
height[i]  ~ normal(mu + Bage*age[i], sigma);
}
generated quantities {
real log_prob;
log_prob <- 0;
for (k in 1:n)
log_prob <- log_prob + normal_log(height[k], mu + Bage*age[k], sigma);
}
"
library(rstan)
stanDso = stan_model(model_code = mod)
sfit1 = sampling(stanDso, dataList)
n=100
age = runif(n=n, min=1, max=17)
MU = 40
height = MU + age*9 + rnorm(n=n, 0,15)
height
plot(height ~ age)
dataList = list(n=n, age=age, height=height)
sfit1 = sampling(stanDso, dataList)
print(sfit)
summary(lm(height ~ sex + age))
summary(lm(height ~ age))
n=100
age = runif(n=n, min=1, max=17)
MU = 40
height = MU + age*9 + rnorm(n=n, 0,15)
height
plot(height ~ age)
dataList = list(n=n, age=age, height=height)
mod = "
data{
int n;
vector[n] height;
vector[n] age;
}
parameters{
real mu;
real Bage;
real<lower=0, upper=100> sigma;
}
model{
mu ~ normal(40, 100);
Bage ~ normal(10, 10);
for (i in 1:n)
height[i]  ~ normal(mu + Bage*age[i], sigma);
}
generated quantities {
real log_prob;
log_prob <- 0;
for (k in 1:n)
log_prob <- log_prob + normal_log(height[k], mu + Bage*age[k], sigma);
}
"
library(rstan)
stanDso = stan_model(model_code = mod)
sfit1 = sampling(stanDso, dataList)
print(sfit)
summary(lm(height ~ age))
print(sfit1)
dataList = list(n=n, age=age, height=height)
mod2 = "
data{
int n;
vector[n] height;
}
parameters{
real mu;
real<lower=0, upper=100> sigma;
}
model{
mu ~ normal(40, 100);
for (i in 1:n)
height[i] ~ normal(mu, sigma);
}
generated quantities {
real log_prob;
log_prob <- 0;
for (k in 1:n)
log_prob <- log_prob + normal_log(height[k], mu, sigma);
}
"
stanDso2 = stan_model(model_code = mod2)
sfit2 = sampling(stanDso2, dataList)
print(sfit2)
summary(lm(height ~ age))
mean(height); sd(height)
extract(sfit1, pars="lp__")
str(extract(sfit1, pars="lp__"))
str(as.data.frame(extract(sfit1, pars="lp__")))
mean(as.data.frame(extract(sfit1, pars="lp__")))
mean(as.data.frame(extract(sfit1, pars="lp__"))[,1])
mean(as.data.frame(extract(sfit2, pars="lp__"))[,1])
print(sfit2)
mean(as.data.frame(extract(sfit1, pars="log_prob"))[,1])
mean(as.data.frame(extract(sfit2, pars="log_prob"))[,1])
library("BayesFactor", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
library(BayesFactor)
lmBF(height ~ 1)
lmBF(height ~ 1, data=data.frame(height))
lmBF(height ~ age, data=data.frame(height, age))
bf1 = lmBF(height ~ age, data=data.frame(height, age))
bf1
str(bf1)
bf1@bayesFactor$bf
bf1
1/bf1@bayesFactor$bf
mean(as.data.frame(extract(sfit1, pars="log_prob"))[,1])
mean(as.data.frame(extract(sfit2, pars="log_prob"))[,1])
429/520
N=9
z=6
y = c( rep(0,N-z) , rep(1,z) )
dataList = list(
y = y ,
N = N
)
y
rep(0,N-z)
rep(1,z)
?stan_model
mod = "
data{
int N;
int[N] y;
}
parameters{
vector[2] omega;
real omega[1] <- .25;
real omega[2] <- .75;
int kappa <- 12;
vector[2] mPriorProb;
mPriorProb[1] <- 0.5;
mPriorProb[2] <- 0.5;
}
model{
m ~ categorical(mPriorProb[])
theta ~ beta( omega[m]*(kappa-2)+1, (1-omega[m])*(kappa-2)+1 )
for ( i in 1:N )
y[i] ~ bernoulli( theta );"
library(rstan)
stanDso = stan_model( model_name="mod" )
stanDso = stan_model( model_code="mod" )
mod = "
data{
int N;
vector[N] y;
}
parameters{
vector[2] omega;
real omega[1] <- .25;
real omega[2] <- .75;
int kappa <- 12;
vector[2] mPriorProb;
mPriorProb[1] <- 0.5;
mPriorProb[2] <- 0.5;
}
model{
m ~ categorical(mPriorProb[])
theta ~ beta( omega[m]*(kappa-2)+1, (1-omega[m])*(kappa-2)+1 )
for ( i in 1:N )
y[i] ~ bernoulli( theta );"
stanDso = stan_model( model_code="mod" )
mod = "
data{
int N;
vector[N] y;
vector[2] omega;
}
parameters{
int kappa <- 12;
vector[2] mPriorProb;
mPriorProb[1] <- 0.5;
mPriorProb[2] <- 0.5;
}
model{
m ~ categorical(mPriorProb[])
theta ~ beta( omega[m]*(kappa-2)+1, (1-omega[m])*(kappa-2)+1 )
for ( i in 1:N )
y[i] ~ bernoulli( theta );"
stanDso = stan_model( model_code="mod" )
mod = "
data{
int N;
vector[N] y;
vector[2] omega;
int kappa;
}
parameters{
vector[2] mPriorProb;
mPriorProb[1] <- 0.5;
mPriorProb[2] <- 0.5;
}
model{
m ~ categorical(mPriorProb[])
theta ~ beta( omega[m]*(kappa-2)+1, (1-omega[m])*(kappa-2)+1 )
for ( i in 1:N )
y[i] ~ bernoulli( theta );"
stanDso = stan_model( model_code="mod" )
mod = "
data{
int N;
vector[N] y;
vector[2] omega;
int kappa;
vector[2] mPriorProb;
}
parameters{
}
model{
m ~ categorical(mPriorProb[])
theta ~ beta( omega[m]*(kappa-2)+1, (1-omega[m])*(kappa-2)+1 )
for ( i in 1:N )
y[i] ~ bernoulli( theta );"
stanDso = stan_model( model_code="mod" )
mod = "
data{
int N;
vector[N] y;
vector[2] omega;
int kappa;
vector[2] mPriorProb;
}
parameters{
real m;
}
model{
m ~ categorical(mPriorProb[])
theta ~ beta( omega[m]*(kappa-2)+1, (1-omega[m])*(kappa-2)+1 )
for ( i in 1:N )
y[i] ~ bernoulli( theta );"
stanDso = stan_model( model_code="mod" )
mod = "
data{
int N;
vector[N] y;
vector[2] omega;
int kappa;
vector[2] mPriorProb;
}
parameters{
real m;
}
model{
m ~ categorical(mPriorProb)
theta ~ beta( omega[m]*(kappa-2)+1, (1-omega[m])*(kappa-2)+1 )
for ( i in 1:N )
y[i] ~ bernoulli( theta );"
stanDso = stan_model( model_code="mod" )
mod = "
data{
int N;
vector[N] y;
vector[2] omega;
int kappa;
vector[2] mPriorProb;
}
parameters{
real m;
}
model{
m ~ categorical(mPriorProb);
theta ~ beta( omega[m]*(kappa-2)+1, (1-omega[m])*(kappa-2)+1 );
for ( i in 1:N )
y[i] ~ bernoulli( theta );"
stanDso = stan_model( model_code="mod" )
rm(list=ls(all=TRUE))
setwd("~/github/dbda/DBDA2Eprograms")
source("DBDA2E-utilities.R")
require(rjags)
fileNameRoot="Jags-Ydich-Xnom1subj-MbernBetaModelComp-" # for output filenames
#------------------------------------------------------------------------------
# THE DATA.
N=9
z=6
y = c( rep(0,N-z) , rep(1,z) )
dataList = list(
y = y ,
N = N
)
modelString = "
model {
for ( i in 1:N ) {
y[i] ~ dbern( theta )
}
theta ~ dbeta( omega[m]*(kappa-2)+1 , (1-omega[m])*(kappa-2)+1 )
omega[1] <- .25
omega[2] <- .75
kappa <- 12
m ~ dcat( mPriorProb[] )
mPriorProb[1] <- .5
mPriorProb[2] <- .5
}
" # close quote for modelString
writeLines( modelString , con="TEMPmodel.txt" )
parameters = c("theta","m")
adaptSteps = 1000             # Number of steps to "tune" the samplers.
burnInSteps = 1000           # Number of steps to "burn-in" the samplers.
nChains = 4                   # Number of chains to run.
numSavedSteps=50000          # Total number of steps in chains to save.
thinSteps=1                   # Number of steps to "thin" (1=keep every step).
nPerChain = ceiling( ( numSavedSteps * thinSteps ) / nChains ) # Steps per chain.
# Create, initialize, and adapt the model:
jagsModel = jags.model( "TEMPmodel.txt" , data=dataList , # inits=initsList ,
n.chains=nChains , n.adapt=adaptSteps )
cat( "Burning in the MCMC chain...\n" )
update( jagsModel , n.iter=burnInSteps )
# The saved MCMC chain:
cat( "Sampling final MCMC chain...\n" )
codaSamples = coda.samples( jagsModel , variable.names=parameters ,
n.iter=nPerChain , thin=thinSteps )
save( codaSamples , file=paste0(fileNameRoot,"Mcmc.Rdata") )
str(codaSamples)
parameterNames = varnames(codaSamples) # get all parameter names
for ( parName in parameterNames ) {
diagMCMC( codaSamples , parName=parName ,
saveName=fileNameRoot , saveType="eps" )
}
mcmcMat = as.matrix( codaSamples , chains=TRUE )
m = mcmcMat[,"m"]
theta = mcmcMat[,"theta"]
m
summary(m)
table(m)
theta
pM1 = sum( m == 1 ) / length( m )
pM2 = 1 - pM1
# Extract theta values for each model index:
thetaM1 = theta[ m == 1 ]
thetaM2 = theta[ m == 2 ]
mod = "
data{
int N;
vector[N] y;
}
parameters{
real m;
real theta;
}
model{
m ~ uniform(1,50);
theta ~ beta(m,m);
for (i in 1:N)
y ~ bernoulli(theta);
}
"
dso = stan_model(model_code="mod")
library(rstan)
dso = stan_model(model_code="mod")
library(repsych)
set.seed(99)
x = latinSquareDigram(c('active', 'active', 'active', 'active', 'passive', 'passive', 'passive', 'passive'))
x[[1]][-c(3,7),]
# Counterbalance allocation
subjs = c(sample(rep(c(1,2,3,4,5,6), 4)), 1, 4)
table(subjs)
subjs
x[[1]][-c(3,7),]
x
subjs = c(sample(rep(c(1,2,3,4,5,6), 4)), 1, 4)
table(subjs)
subjs
x = latinSquareDigram(c('active', 'passive', 'no action'))
x[[1]][-c(3,7),]
x
?latinSquareDigram
x = latinSquareCyclic(c('active', 'passive', 'no action'))
x
x = createSquareMatrix(c('active', 'passive', 'no action'))
library(timeline)
```{r}
install.packages("timeline")
ww2
library(timeline)
ww2
timeline::ww2
timeline:::ww2
demo(ww2)
timeline(ww2)
data.frame(ww2)
data.frame(ww2.events)
library(repsych)
set.seed(99)
x = latinSquareDigram(c('active', 'active', 'passive', 'passive', 'no action', 'no action'))
x
# Counterbalance allocation
subjs = c(sample(rep(c(1,2,3,4,5,6), 4)), 1, 4)
table(subjs)
subjs
set.seed(99)
latinSquareDigram(c('passive', 'passive', 'no action', 'no action', 'active', 'active'))
# Counterbalance allocation
subjs = c(sample(rep(c(1,2,3,4), 6)), 1, 2)
table(subjs)
subjs
set.seed(1)
latinSquareDigram(c('passive', 'passive', 'no action', 'no action', 'active', 'active'))
# Counterbalance allocation
subjs = c(sample(rep(c(1,2,3,4), 6)), 1, 2)
table(subjs)
subjs
library(slidify)
slidify("index.Rmd")
setwd("~/github/psych-git/psych-slides/revealjs")
slidify("index.Rmd")
slidify("index.Rmd")
slidify("index.Rmd")
slidify("index.Rmd")
slidify("index.Rmd")
slidify("index.Rmd")
library(slidifyLibraries)
slidify("index.Rmd")
